{
  "data": [
    {
      "dataType": "python",
      "bodyData": {
        "document": {
          "savedAt": "2024/11/6 16:46:23",
          "sources": [
            {
              "fileExtension": "py",
              "filename": "new_app.py",
              "content": "import streamlit as st\nimport openai\nimport os\nfrom pathlib import Path\nimport zipfile\nimport chardet  # ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è‡ªå‹•æ¤œå‡ºãƒ©ã‚¤ãƒ–ãƒ©ãƒª\nfrom aozora_preprocess import save_cleanse_text  # å‰å‡¦ç†ã®é–¢æ•°ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ\n\nauthor_id = '000879'  # é’ç©ºæ–‡åº«ã®ä½œå®¶ç•ªå·\nauthor_name = 'èŠ¥å·é¾ä¹‹ä»‹'  # é’ç©ºæ–‡åº«ã®è¡¨è¨˜ã§ã®ä½œå®¶å\n\n# ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§£å‡ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°\n@st.cache_data\ndef load_all_texts_from_zip(zip_file):\n    all_texts = \"\"\n    unzip_dir = Path(\"unzipped_files\")\n    unzip_dir.mkdir(exist_ok=True)\n\n    with zipfile.ZipFile(zip_file, 'r') as zip_ref:\n        zip_ref.extractall(unzip_dir)  # è§£å‡å…ˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª\n\n    text_files = list(unzip_dir.glob('**/*.txt'))\n    for file_path in text_files:\n        # ã¾ãšãƒã‚¤ãƒˆå½¢å¼ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’æ¤œå‡º\n        with open(file_path, 'rb') as f:\n            raw_data = f.read()\n            result = chardet.detect(raw_data)\n            encoding = result['encoding']  # æ¤œå‡ºã•ã‚ŒãŸã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’å–å¾—\n\n        try:\n            with open(file_path, \"r\", encoding=encoding) as f:\n                all_texts += f.read() + \"\\n\"\n        except UnicodeDecodeError:\n            st.warning(f\"ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\")\n\n    return all_texts\n\n# ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã™ã‚‹é–¢æ•°\ndef process_text_files():\n    processed_texts = []  # å‡¦ç†å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ ¼ç´ã™ã‚‹ãƒªã‚¹ãƒˆ\n    unzip_dir = Path(\"unzipped_files\")\n    text_files = list(unzip_dir.glob('**/*.txt'))  # ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚‚å«ã‚€\n\n    for text_file in text_files:\n        cleaned_df = save_cleanse_text(text_file, unzip_dir)  # å‰å‡¦ç†é–¢æ•°ã‚’å‘¼ã³å‡ºã—\n        if cleaned_df is not None:\n            # æ•´å½¢å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ \n            processed_texts.append(cleaned_df.to_string(index=False))\n\n    return processed_texts\n\n# ã™ã¹ã¦ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®šã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰èª­ã¿è¾¼ã‚€\nzip_files_directory = Path(\"000879/files/\")\nst.write(\"Resolved Path:\", zip_files_directory.resolve())\n\nprint(\"Resolved Path:\", zip_files_directory)\n# ç¾åœ¨ã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¡¨ç¤º\nprint(\"Current Working Directory:\", os.getcwd())\n# ç¾åœ¨ã®ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¡¨ç¤º\nst.write(\"Current Working Directory:\", os.getcwd())\n\n\n# ç¢ºèªã—ãŸã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹\ncheck_path = Path(\"/mount/src/openai_api_bot_akutagawa\")\n\n# ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª\nif check_path.exists():\n    st.write(\"Files in directory:\")\n    for file in check_path.iterdir():\n        st.write(file.name)\nelse:\n    st.write(\"Directory does not exist.\")\n\n\n\n\nzip_files = list(zip_files_directory.glob('*.zip'))  # ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—\n\n# å…¨ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã™ã¹ã¦ã®ZIPãƒ•ã‚¡ã‚¤ãƒ«ã«å¯¾ã—ã¦å‡¦ç†ã‚’è¡Œã†ï¼‰\nall_processed_texts = []\nfor zip_file_path in zip_files:\n    load_all_texts_from_zip(zip_file_path)  # ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿\n    processed_texts = process_text_files()  # ãƒ†ã‚­ã‚¹ãƒˆã®å‡¦ç†\n    all_processed_texts.extend(processed_texts)  # ã™ã¹ã¦ã®å‡¦ç†ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ \n\n# æ•´å½¢å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º\nst.text_area(\"æ•´å½¢å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿\", \"\\n\\n\".join(all_processed_texts), height=300)\n\n# Streamlit Community Cloudã®ã€ŒSecretsã€ã‹ã‚‰OpenAI API keyã‚’å–å¾—\nopenai.api_key = st.secrets.OpenAIAPI.openai_api_key\n\n# st.session_stateã‚’ä½¿ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚„ã‚Šã¨ã‚Šã‚’ä¿å­˜\nif \"messages\" not in st.session_state:\n    st.session_state[\"messages\"] = [\n        {\"role\": \"system\", \"content\": st.secrets.AppSettings.chatbot_setting} \n    ]\n\n# ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã¨ã‚„ã‚Šã¨ã‚Šã™ã‚‹é–¢æ•°\ndef communicate():\n    messages = st.session_state[\"messages\"]\n    user_message = {\"role\": \"user\", \"content\": st.session_state[\"user_input\"]}\n    messages.append(user_message)\n\n    response = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=messages\n    )\n\n    bot_message = response[\"choices\"][0][\"message\"]\n    messages.append(bot_message)\n\n    st.session_state[\"user_input\"] = \"\"  # å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªã‚¢\n\n# ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹\nst.title(author_name+\"ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ\")\nst.write(author_name+\"ã®ä½œå“ã«åŸºã¥ã„ãŸãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã§ã™ã€‚\")\n\n# ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¥åŠ›\nuser_input = st.text_input(\"ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚\", key=\"user_input\", on_change=communicate)\n\nif st.session_state[\"messages\"]:\n    messages = st.session_state[\"messages\"]\n    for message in reversed(messages[1:]):  # ç›´è¿‘ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¸Šã«\n        speaker = \"ğŸ™‚\" if message[\"role\"] == \"user\" else \"ğŸ¤–\"\n        st.write(speaker + \": \" + message[\"content\"])\n\n# æ•´å½¢å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º\nprocessed_texts = process_text_files()\nfor i, text in enumerate(processed_texts):\n    st.text_area(f\"æ•´å½¢å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆ {i+1}\", text, height=300)"
            }
          ]
        }
      }
    }
  ]
}