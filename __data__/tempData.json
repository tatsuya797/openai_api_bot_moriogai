{
  "data": [
    {
      "dataType": "python",
      "bodyData": {
        "document": {
          "savedAt": "2024/11/6 16:46:23",
          "sources": [
            {
              "fileExtension": "py",
              "filename": "new_app.py",
              "content": "import streamlit as st\nimport openai\nimport os\nfrom pathlib import Path\nimport zipfile\nimport chardet  # エンコーディング自動検出ライブラリ\nfrom aozora_preprocess import save_cleanse_text  # 前処理の関数をインポート\n\nauthor_id = '000879'  # 青空文庫の作家番号\nauthor_name = '芥川龍之介'  # 青空文庫の表記での作家名\n\n# ZIPファイルを解凍してテキストデータを読み込む関数\n@st.cache_data\ndef load_all_texts_from_zip(zip_file):\n    all_texts = \"\"\n    unzip_dir = Path(\"unzipped_files\")\n    unzip_dir.mkdir(exist_ok=True)\n\n    with zipfile.ZipFile(zip_file, 'r') as zip_ref:\n        zip_ref.extractall(unzip_dir)  # 解凍先のディレクトリ\n\n    text_files = list(unzip_dir.glob('**/*.txt'))\n    for file_path in text_files:\n        # まずバイト形式でファイルを読み込み、エンコーディングを検出\n        with open(file_path, 'rb') as f:\n            raw_data = f.read()\n            result = chardet.detect(raw_data)\n            encoding = result['encoding']  # 検出されたエンコーディングを取得\n\n        try:\n            with open(file_path, \"r\", encoding=encoding) as f:\n                all_texts += f.read() + \"\\n\"\n        except UnicodeDecodeError:\n            st.warning(f\"ファイル {file_path} の読み込みに失敗しました。\")\n\n    return all_texts\n\n# テキストデータを処理する関数\ndef process_text_files():\n    processed_texts = []  # 処理後のテキストを格納するリスト\n    unzip_dir = Path(\"unzipped_files\")\n    text_files = list(unzip_dir.glob('**/*.txt'))  # サブフォルダも含む\n\n    for text_file in text_files:\n        cleaned_df = save_cleanse_text(text_file, unzip_dir)  # 前処理関数を呼び出し\n        if cleaned_df is not None:\n            # 整形後のテキストをリストに追加\n            processed_texts.append(cleaned_df.to_string(index=False))\n\n    return processed_texts\n\n# すべてのZIPファイルを指定したディレクトリから読み込む\nzip_files_directory = Path(\"000879/files/\")\nst.write(\"Resolved Path:\", zip_files_directory.resolve())\n\nprint(\"Resolved Path:\", zip_files_directory)\n# 現在のカレントディレクトリを表示\nprint(\"Current Working Directory:\", os.getcwd())\n# 現在のカレントディレクトリを表示\nst.write(\"Current Working Directory:\", os.getcwd())\n\n\n# 確認したいディレクトリのパス\ncheck_path = Path(\"/mount/src/openai_api_bot_akutagawa\")\n\n# ディレクトリが存在するか確認\nif check_path.exists():\n    st.write(\"Files in directory:\")\n    for file in check_path.iterdir():\n        st.write(file.name)\nelse:\n    st.write(\"Directory does not exist.\")\n\n\n\n\nzip_files = list(zip_files_directory.glob('*.zip'))  # ZIPファイルを取得\n\n# 全テキストデータを読み込む（すべてのZIPファイルに対して処理を行う）\nall_processed_texts = []\nfor zip_file_path in zip_files:\n    load_all_texts_from_zip(zip_file_path)  # ZIPファイルの読み込み\n    processed_texts = process_text_files()  # テキストの処理\n    all_processed_texts.extend(processed_texts)  # すべての処理されたテキストを追加\n\n# 整形後のテキストを表示\nst.text_area(\"整形後のテキストデータ\", \"\\n\\n\".join(all_processed_texts), height=300)\n\n# Streamlit Community Cloudの「Secrets」からOpenAI API keyを取得\nopenai.api_key = st.secrets.OpenAIAPI.openai_api_key\n\n# st.session_stateを使いメッセージのやりとりを保存\nif \"messages\" not in st.session_state:\n    st.session_state[\"messages\"] = [\n        {\"role\": \"system\", \"content\": st.secrets.AppSettings.chatbot_setting} \n    ]\n\n# チャットボットとやりとりする関数\ndef communicate():\n    messages = st.session_state[\"messages\"]\n    user_message = {\"role\": \"user\", \"content\": st.session_state[\"user_input\"]}\n    messages.append(user_message)\n\n    response = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=messages\n    )\n\n    bot_message = response[\"choices\"][0][\"message\"]\n    messages.append(bot_message)\n\n    st.session_state[\"user_input\"] = \"\"  # 入力欄をクリア\n\n# ユーザーインターフェイス\nst.title(author_name+\"チャットボット\")\nst.write(author_name+\"の作品に基づいたチャットボットです。\")\n\n# ユーザーのメッセージ入力\nuser_input = st.text_input(\"メッセージを入力してください。\", key=\"user_input\", on_change=communicate)\n\nif st.session_state[\"messages\"]:\n    messages = st.session_state[\"messages\"]\n    for message in reversed(messages[1:]):  # 直近のメッセージを上に\n        speaker = \"🙂\" if message[\"role\"] == \"user\" else \"🤖\"\n        st.write(speaker + \": \" + message[\"content\"])\n\n# 整形後のテキストを表示\nprocessed_texts = process_text_files()\nfor i, text in enumerate(processed_texts):\n    st.text_area(f\"整形後のテキスト {i+1}\", text, height=300)"
            }
          ]
        }
      }
    }
  ]
}